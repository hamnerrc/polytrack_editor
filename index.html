<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>PolyTrack Map Maker — Pixel Art</title>
    <script src="https://unpkg.com/fflate@0.8.2/umd/index.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: .5rem;
            text-shadow: 0 0 20px rgba(0, 255, 136, .4);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 1.5rem;
        }

        @media (max-width:900px) {
            .grid {
                grid-template-columns: 1fr
            }
        }

        .panel {
            background: rgba(0, 0, 0, .4);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.08);
        }

        h2 {
            color: #00ff88;
            margin-bottom: .75rem;
            font-size: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: .35rem;
            color: #00ff88;
            font-weight: 600;
        }

        input,
        select,
        textarea,
        button {
            font-family: 'Courier New', monospace;
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: .6rem;
            background: rgba(0, 0, 0, .6);
            border: 1px solid #00ff88;
            border-radius: 6px;
            color: #00ff88;
            font-size: 1rem;
        }

        .input-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: .5rem;
        }

        .btn {
            padding: .6rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            color: #000;
        }

        .small {
            padding: .35rem .6rem;
            font-size: .85rem;
        }

        .output-box {
            background: #000;
            border: 2px solid #00ff88;
            border-radius: 6px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            max-height: 260px;
            overflow: auto;
            color: #00ff88;
        }

        .block-list {
            max-height: 300px;
            overflow: auto;
            background: rgba(0, 0, 0, .4);
            border: 1px solid #00ff88;
            border-radius: 6px;
            padding: .5rem;
        }

        .block-item {
            background: rgba(0, 255, 136, .06);
            padding: .6rem;
            border-radius: 6px;
            margin-bottom: .5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        canvas {
            background: #071025;
            display: block;
            max-width: 100%;
            border-radius: 6px;
            margin-top: .5rem;
        }

        .row {
            display: flex;
            gap: .5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .col {
            display: flex;
            flex-direction: column;
            gap: .5rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>PolyTrack Map Maker</h1>
        <div class="grid">
            <div class="panel">
                <h2>Shape Builder</h2>
                <div class="form-group">
                    <label>Shape Type</label>
                    <select id="shapeType">
                        <option value="line">Line</option>
                        <option value="filledRect">Filled Rectangle</option>
                        <option value="hollowCube">Hollow Cube</option>
                        <option value="filledCube">Filled Cube</option>
                    </select>
                </div>
                <div id="shapeParams">
                    <div id="form-line" class="shape-form">
                        <div class="form-group">
                            <label>Block ID (5=Start, 6=Finish, 25=Road, etc.)</label>
                            <input type="number" id="lineId" value="25" min="0" max="255">
                        </div>
                        <div class="form-group">
                            <label>Start Position (X, Y, Z)</label>
                            <div class="input-row">
                                <input type="number" id="lineStartX" value="0" placeholder="X">
                                <input type="number" id="lineStartY" value="0" placeholder="Y">
                                <input type="number" id="lineStartZ" value="0" placeholder="Z">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>End Position (X, Y, Z)</label>
                            <div class="input-row">
                                <input type="number" id="lineEndX" value="100" placeholder="X">
                                <input type="number" id="lineEndY" value="0" placeholder="Y">
                                <input type="number" id="lineEndZ" value="0" placeholder="Z">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Rotation (0-3)</label>
                            <input type="number" id="lineRot" value="0" min="0" max="3">
                        </div>
                    </div>
                    <div id="form-filledRect" class="shape-form" style="display:none;">
                        <div class="form-group">
                            <label>Plane</label>
                            <select id="rectPlane">
                                <option value="xz">XZ (Horizontal)</option>
                                <option value="xy">XY (Vertical)</option>
                                <option value="yz">YZ (Vertical)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label id="fixedLabel">Fixed Y</label>
                            <input type="number" id="fixedCoord" value="0">
                        </div>
                        <div class="form-group">
                            <label id="min1Label">Min X</label>
                            <input type="number" id="rectMin1" value="0">
                        </div>
                        <div class="form-group">
                            <label id="max1Label">Max X</label>
                            <input type="number" id="rectMax1" value="100">
                        </div>
                        <div class="form-group">
                            <label id="min2Label">Min Z</label>
                            <input type="number" id="rectMin2" value="0">
                        </div>
                        <div class="form-group">
                            <label id="max2Label">Max Z</label>
                            <input type="number" id="rectMax2" value="100">
                        </div>
                        <div class="form-group">
                            <label>Block ID</label>
                            <input type="number" id="rectId" value="25" min="0" max="255">
                        </div>
                        <div class="form-group">
                            <label>Rotation (0-3)</label>
                            <input type="number" id="rectRot" value="0" min="0" max="3">
                        </div>
                    </div>
                    <div id="form-hollowCube" class="shape-form" style="display:none;">
                        <div class="form-group">
                            <label>Min Position (X, Y, Z)</label>
                            <div class="input-row">
                                <input type="number" id="hollowCubeMinX" value="0" placeholder="X">
                                <input type="number" id="hollowCubeMinY" value="0" placeholder="Y">
                                <input type="number" id="hollowCubeMinZ" value="0" placeholder="Z">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Max Position (X, Y, Z)</label>
                            <div class="input-row">
                                <input type="number" id="hollowCubeMaxX" value="100" placeholder="X">
                                <input type="number" id="hollowCubeMaxY" value="100" placeholder="Y">
                                <input type="number" id="hollowCubeMaxZ" value="100" placeholder="Z">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Block ID</label>
                            <input type="number" id="hollowCubeId" value="25" min="0" max="255">
                        </div>
                        <div class="form-group">
                            <label>Rotation (0-3)</label>
                            <input type="number" id="hollowCubeRot" value="0" min="0" max="3">
                        </div>
                    </div>
                    <div id="form-filledCube" class="shape-form" style="display:none;">
                        <div class="form-group">
                            <label>Min Position (X, Y, Z)</label>
                            <div class="input-row">
                                <input type="number" id="filledCubeMinX" value="0" placeholder="X">
                                <input type="number" id="filledCubeMinY" value="0" placeholder="Y">
                                <input type="number" id="filledCubeMinZ" value="0" placeholder="Z">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Max Position (X, Y, Z)</label>
                            <div class="input-row">
                                <input type="number" id="filledCubeMaxX" value="100" placeholder="X">
                                <input type="number" id="filledCubeMaxY" value="100" placeholder="Y">
                                <input type="number" id="filledCubeMaxZ" value="100" placeholder="Z">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Block ID</label>
                            <input type="number" id="filledCubeId" value="25" min="0" max="255">
                        </div>
                        <div class="form-group">
                            <label>Rotation (0-3)</label>
                            <input type="number" id="filledCubeRot" value="0" min="0" max="3">
                        </div>
                    </div>
                </div>
                <div style="margin-top:.75rem;">
                    <button class="btn btn-primary" onclick="addShape()">Add Shape</button>
                </div>
            </div>
            <div class="panel">
                <h2>Procedural Generators</h2>
                <div class="form-group">
                    <label>Min ID</label>
                    <input type="number" id="minId" value="1" min="0" max="255">
                </div>
                <div class="form-group">
                    <label>Max ID</label>
                    <input type="number" id="maxId" value="50" min="0" max="255">
                </div>
                <div class="presets" style="display:flex; gap:.5rem; margin-top:.5rem;">
                    <button class="btn small" onclick="generateTestTrack()">ID Test Track</button>
                </div>
            </div>
        </div>
        <div class="grid">
            <div class="panel">
                <h2>Track Lines</h2>
                <div class="block-list" id="linesList">
                    <p style="opacity:0.5;">No lines added yet.</p>
                </div>
                <div style="display:flex; gap:.5rem; margin-top:.5rem;">
                    <button class="btn btn-danger" onclick="clearLines()">Clear All Lines</button>
                    <button class="btn" onclick="downloadLinesJSON()">Export JSON</button>
                </div>
            </div>
            <div class="panel">
                <h2>Track Settings</h2>
                <div class="form-group">
                    <label>Track Name</label>
                    <input type="text" id="trackName" value="My Awesome Track" maxlength="50">
                </div>
                <div class="form-group">
                    <label>Author Name</label>
                    <input type="text" id="authorName" value="Builder" maxlength="50">
                </div>
                <div style="margin-top:.5rem;">
                    <button class="btn btn-primary" style="font-size:1.05rem;padding:1rem;"
                        onclick="generateTrack()">GENERATE TRACK CODE</button>
                </div>
            </div>
        </div>
        <!-- PIXEL ART PANEL -->
        <div class="panel">
            <h2>Pixel Art Import</h2>
            <div class="row" style="gap:1rem;">
                <div style="flex:1; min-width:260px;">
                    <label>Upload image (PNG/JPEG)</label>
                    <input type="file" id="imgUpload" accept="image/*">
                    <label style="margin-top:.5rem;">Resolution (shortest side when preserve checked)</label>
                    <div style="display:flex; gap:.5rem; align-items:center;">
                        <input type="number" id="resValue" value="128" min="8" max="512" style="width:100px;">
                        <label style="margin-left:.5rem;"><input type="checkbox" id="preserveAspect" checked> Preserve
                            aspect (shortest side = res)</label>
                    </div>
                    <label style="margin-top:.5rem;">Spacing (blocks per pixel)</label>
                    <input type="number" id="pixelSpacing" value="1" min="1" max="10">
                    <label style="margin-top:.5rem;"><input type="checkbox" id="use4x" checked> 4× block size (PolyTrack
                        scaling)</label>
                    <label style="margin-top:.5rem;">Offset (X,Y,Z)</label>
                    <div style="display:flex; gap:.5rem;">
                        <input type="number" id="offsetX" value="0" placeholder="X">
                        <input type="number" id="offsetY" value="0" placeholder="Y">
                        <input type="number" id="offsetZ" value="0" placeholder="Z">
                    </div>
                    <label style="margin-top:.5rem;">Darkest ID</label>
                    <input type="number" id="idBin0" value="5" min="0" max="255">
                    <label style="margin-top:.5rem;">Medium Dark ID</label>
                    <input type="number" id="idBin1" value="6" min="0" max="255">
                    <label style="margin-top:.5rem;">Medium Light ID</label>
                    <input type="number" id="idBin2" value="52" min="0" max="255">
                    <label style="margin-top:.5rem;">Brightest ID (0=random)</label>
                    <input type="number" id="idBin3" value="0" min="0" max="255">
                    <div style="display:flex; gap:.5rem; margin-top:.5rem;">
                        <button class="btn btn-primary" onclick="processUpload()">Process & Preview</button>
                        <button class="btn" onclick="convertPreviewToLines()">Add Pixel Art to Track</button>
                    </div>
                </div>
                <div style="width:420px; max-width:50%;">
                    <label>Preview (click to toggle zoom)</label>
                    <canvas id="previewCanvas" width="320" height="320"></canvas>
                    <div style="display:flex; gap:.5rem; margin-top:.5rem; align-items:center;">
                        <div class="col" style="min-width:160px;">
                            <label>Legend</label>
                            <div style="display:flex; gap:.35rem; align-items:center; flex-wrap:wrap;">
                                <div style="width:22px; height:22px; background:#0000ff; border-radius:4px;"></div>
                                <div>Blue → ID <span id="legId0">5</span></div>
                                <div
                                    style="width:22px; height:22px; background:#ff0000; border-radius:4px; margin-left:6px;">
                                </div>
                                <div>Red → ID <span id="legId1">6</span></div>
                                <div
                                    style="width:22px; height:22px; background:#ffff00; border-radius:4px; margin-left:6px;">
                                </div>
                                <div>Yellow → ID <span id="legId2">52</span></div>
                                <div
                                    style="width:22px; height:22px; background:#ffffff; border-radius:4px; margin-left:6px;">
                                </div>
                                <div>White → ID <span id="legId3">random</span></div>
                            </div>
                        </div>
                        <div style="flex:1;">
                            <label>Statistics</label>
                            <div style="display:flex; gap:.5rem; margin-top:.25rem;">
                                <div class="stat-box"
                                    style="background:rgba(0,255,136,.06); padding:.5rem; border-radius:6px;">
                                    <div id="pixCount" style="font-weight:bold; font-size:1.2rem; color:#00ffff;">0
                                    </div>
                                    <div style="opacity:.8;">Pixels</div>
                                </div>
                                <div class="stat-box"
                                    style="background:rgba(0,255,136,.06); padding:.5rem; border-radius:6px;">
                                    <div id="uniqueIDs" style="font-weight:bold; font-size:1.2rem; color:#00ffff;">0
                                    </div>
                                    <div style="opacity:.8;">Unique IDs</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel">
            <h2>Output Code</h2>
            <div class="output-box" id="outputCode">Click "GENERATE TRACK CODE" to create your PolyTrack map...</div>
            <div style="display:flex; gap:.5rem; margin-top:.5rem;">
                <button class="btn" onclick="copyCode()">Copy to Clipboard</button>
                <button class="btn" onclick="downloadCodeFile()">Download .txt</button>
            </div>
        </div>
    </div>
    <script>
        const CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        let lines = [];
        let previewPixels = null;
        let lastSeed = 0;

        function encode62(buf) {
            let bitPos = 0, res = "";
            while (bitPos < buf.length * 8) {
                let val = 0;
                const byteIdx = bitPos >>> 3;
                const off = bitPos & 7;
                if (byteIdx >= buf.length) break;
                if (off <= 2 || byteIdx >= buf.length - 1) {
                    val = (buf[byteIdx] >>> off) & 63;
                } else {
                    val = ((buf[byteIdx] >>> off) & 63) |
                        ((buf[byteIdx + 1] & (63 >>> (8 - off))) << (8 - off));
                }
                if ((val & 30) === 30) { val &= 31; bitPos += 5; } else { bitPos += 6; }
                res += CHARS[val];
            }
            return res;
        }

        function compress(data) {
            return fflate.zlibSync(data, { level: 9, mem: 8 });
        }

        function getBytesNeeded(max) {
            return max < 128 ? 1 : max < 32768 ? 2 : max < 8388608 ? 3 : 4;
        }

        function writeU32(bin, v) {
            bin.push(v & 255, (v >> 8) & 255, (v >> 16) & 255, (v >> 24) & 255);
        }

        function writeCoord(bin, v, bytes) {
            for (let i = 0; i < bytes; i++) bin.push((v >> (i * 8)) & 255);
        }

        function line3D(x1, y1, z1, x2, y2, z2) {
            const points = [];
            let dx = x2 - x1;
            let dy = y2 - y1;
            let dz = z2 - z1;
            const ax = Math.abs(dx);
            const ay = Math.abs(dy);
            const az = Math.abs(dz);
            const sx = dx > 0 ? 1 : -1;
            const sy = dy > 0 ? 1 : -1;
            const sz = dz > 0 ? 1 : -1;
            let x = x1;
            let y = y1;
            let z = z1;
            if (ax >= ay && ax >= az) { // x dominant
                let yd = ay - (ax / 2);
                let zd = az - (ax / 2);
                while (true) {
                    points.push({ x, y, z });
                    if (x === x2) return points;
                    x += sx;
                    if (yd >= 0) { y += sy; yd -= ax; }
                    yd += ay;
                    if (zd >= 0) { z += sz; zd -= ax; }
                    zd += az;
                }
            } else if (ay >= ax && ay >= az) { // y dominant
                let xd = ax - (ay / 2);
                let zd = az - (ay / 2);
                while (true) {
                    points.push({ x, y, z });
                    if (y === y2) return points;
                    y += sy;
                    if (xd >= 0) { x += sx; xd -= ay; }
                    xd += ax;
                    if (zd >= 0) { z += sz; zd -= ay; }
                    zd += az;
                }
            } else { // z dominant
                let xd = ax - (az / 2);
                let yd = ay - (az / 2);
                while (true) {
                    points.push({ x, y, z });
                    if (z === z2) return points;
                    z += sz;
                    if (xd >= 0) { x += sx; xd -= az; }
                    xd += ax;
                    if (yd >= 0) { y += sy; yd -= az; }
                    yd += ay;
                }
            }
        }

        function buildFromLines(linesList) {
            const bin = [];
            bin.push(0, 0);
            writeU32(bin, 0); writeU32(bin, 0); writeU32(bin, 0);
            let maxX = 0, maxY = 0, maxZ = 0;
            linesList.forEach(l => {
                l.points.forEach(p => {
                    maxX = Math.max(maxX, Math.abs(p.x));
                    maxY = Math.max(maxY, Math.abs(p.y));
                    maxZ = Math.max(maxZ, Math.abs(p.z));
                });
            });
            const xB = getBytesNeeded(maxX);
            const yB = getBytesNeeded(maxY);
            const zB = getBytesNeeded(maxZ);
            bin.push((zB << 4) | (yB << 2) | xB);
            const groups = {};
            linesList.forEach(l => {
                if (!groups[l.id]) groups[l.id] = [];
                groups[l.id].push(...l.points.map(p => ({
                    ...p,
                    rot: l.rot || 0,
                    dir: l.dir || 0,
                    color: l.color || 0
                })));
            });
            Object.keys(groups).sort((a, b) => +a - +b).forEach(id => {
                const blocks = groups[id];
                bin.push(+id);
                writeU32(bin, blocks.length);
                blocks.forEach(b => {
                    writeCoord(bin, b.x, xB);
                    writeCoord(bin, b.y, yB);
                    writeCoord(bin, b.z, zB);
                    bin.push(b.rot, b.dir, b.color);
                    if ([52, 65, 75, 77].includes(+id)) bin.push(0, 0);
                    if ([5, 91, 92, 93].includes(+id)) writeU32(bin, 0);
                });
            });
            return new Uint8Array(bin);
        }

        function addShape() {
            const type = document.getElementById('shapeType').value;
            if (type === 'line') {
                const id = parseInt(document.getElementById('lineId').value);
                const sx = parseInt(document.getElementById('lineStartX').value);
                const sy = parseInt(document.getElementById('lineStartY').value);
                const sz = parseInt(document.getElementById('lineStartZ').value);
                const ex = parseInt(document.getElementById('lineEndX').value);
                const ey = parseInt(document.getElementById('lineEndY').value);
                const ez = parseInt(document.getElementById('lineEndZ').value);
                const rot = parseInt(document.getElementById('lineRot').value);
                lines.push({
                    id,
                    points: line3D(sx, sy, sz, ex, ey, ez),
                    rot
                });
            } else if (type === 'filledRect') {
                const plane = document.getElementById('rectPlane').value;
                const fixed = parseInt(document.getElementById('fixedCoord').value);
                let min1 = parseInt(document.getElementById('rectMin1').value);
                let max1 = parseInt(document.getElementById('rectMax1').value);
                let min2 = parseInt(document.getElementById('rectMin2').value);
                let max2 = parseInt(document.getElementById('rectMax2').value);
                const id = parseInt(document.getElementById('rectId').value);
                const rot = parseInt(document.getElementById('rectRot').value);
                if (min1 > max1) [min1, max1] = [max1, min1];
                if (min2 > max2) [min2, max2] = [max2, min2];
                if (plane === 'xz') {
                    for (let z = min2; z <= max2; z++) {
                        lines.push({ id, points: line3D(min1, fixed, z, max1, fixed, z), rot });
                    }
                } else if (plane === 'xy') {
                    for (let y = min2; y <= max2; y++) {
                        lines.push({ id, points: line3D(min1, y, fixed, max1, y, fixed), rot });
                    }
                } else if (plane === 'yz') {
                    for (let z = min2; z <= max2; z++) {
                        lines.push({ id, points: line3D(fixed, min1, z, fixed, max1, z), rot });
                    }
                }
            } else if (type === 'hollowCube') {
                let minX = parseInt(document.getElementById('hollowCubeMinX').value);
                let minY = parseInt(document.getElementById('hollowCubeMinY').value);
                let minZ = parseInt(document.getElementById('hollowCubeMinZ').value);
                let maxX = parseInt(document.getElementById('hollowCubeMaxX').value);
                let maxY = parseInt(document.getElementById('hollowCubeMaxY').value);
                let maxZ = parseInt(document.getElementById('hollowCubeMaxZ').value);
                const id = parseInt(document.getElementById('hollowCubeId').value);
                const rot = parseInt(document.getElementById('hollowCubeRot').value);
                if (minX > maxX) [minX, maxX] = [maxX, minX];
                if (minY > maxY) [minY, maxY] = [maxY, minY];
                if (minZ > maxZ) [minZ, maxZ] = [maxZ, minZ];
                // Bottom (XZ at minY)
                for (let z = minZ; z <= maxZ; z++) { lines.push({ id, points: line3D(minX, minY, z, maxX, minY, z), rot }); }
                // Top (XZ at maxY)
                for (let z = minZ; z <= maxZ; z++) { lines.push({ id, points: line3D(minX, maxY, z, maxX, maxY, z), rot }); }
                // Front (XY at minZ)
                for (let y = minY; y <= maxY; y++) { lines.push({ id, points: line3D(minX, y, minZ, maxX, y, minZ), rot }); }
                // Back (XY at maxZ)
                for (let y = minY; y <= maxY; y++) { lines.push({ id, points: line3D(minX, y, maxZ, maxX, y, maxZ), rot }); }
                // Left (YZ at minX)
                for (let z = minZ; z <= maxZ; z++) { lines.push({ id, points: line3D(minX, minY, z, minX, maxY, z), rot }); }
                // Right (YZ at maxX)
                for (let z = minZ; z <= maxZ; z++) { lines.push({ id, points: line3D(maxX, minY, z, maxX, maxY, z), rot }); }
            } else if (type === 'filledCube') {
                let minX = parseInt(document.getElementById('filledCubeMinX').value);
                let minY = parseInt(document.getElementById('filledCubeMinY').value);
                let minZ = parseInt(document.getElementById('filledCubeMinZ').value);
                let maxX = parseInt(document.getElementById('filledCubeMaxX').value);
                let maxY = parseInt(document.getElementById('filledCubeMaxY').value);
                let maxZ = parseInt(document.getElementById('filledCubeMaxZ').value);
                const id = parseInt(document.getElementById('filledCubeId').value);
                const rot = parseInt(document.getElementById('filledCubeRot').value);
                if (minX > maxX) [minX, maxX] = [maxX, minX];
                if (minY > maxY) [minY, maxY] = [maxY, minY];
                if (minZ > maxZ) [minZ, maxZ] = [maxZ, minZ];
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        lines.push({ id, points: line3D(minX, y, z, maxX, y, z), rot });
                    }
                }
            }
            updateUI();
        }

        function clearLines() { lines = []; updateUI(); }

        function removeLine(idx) { lines.splice(idx, 1); updateUI(); }

        function updateUI() {
            const list = document.getElementById('linesList');
            if (lines.length === 0) {
                list.innerHTML = '<p style="opacity:0.5;">No lines added yet.</p>';
            } else {
                list.innerHTML = lines.map((l, i) => `
                    <div class="block-item">
                        <div class="block-info">
                            ID: ${l.id} | ${l.points.length} blocks |
                            (${l.points[0].x},${l.points[0].y},${l.points[0].z})
                        </div>
                        <div>
                            <button class="btn small" onclick="removeLine(${i})">X</button>
                        </div>
                    </div>
                `).join('');
            }
        }

        function generateTrack() {
            if (lines.length === 0) { alert('Add some lines first!'); return; }
            const trackBin = buildFromLines(lines);
            const name = document.getElementById('trackName').value || "Unnamed Track";
            const author = document.getElementById('authorName').value || "Unknown";
            const te = new TextEncoder();
            const nameB = te.encode(name);
            const authB = te.encode(author);
            const prefix = new Uint8Array([nameB.length, ...nameB, authB.length, ...authB]);
            const full = new Uint8Array(prefix.length + trackBin.length);
            full.set(prefix);
            full.set(trackBin, prefix.length);
            const c1 = compress(full);
            const b1 = encode62(c1);
            const c2 = compress(te.encode(b1));
            const final = encode62(c2);
            const code = "PolyTrack1" + final;
            document.getElementById('outputCode').textContent = code;
        }

        function copyCode() {
            const code = document.getElementById('outputCode').textContent;
            navigator.clipboard.writeText(code).then(() => alert('Code copied to clipboard!'));
        }

        function downloadCodeFile() {
            const code = document.getElementById('outputCode').textContent;
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'polytrack_code.txt'; a.click();
            URL.revokeObjectURL(url);
        }

        function downloadLinesJSON() {
            const blob = new Blob([JSON.stringify(lines, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'lines.json'; a.click();
            URL.revokeObjectURL(url);
        }

        function generateTestTrack() {
            lines = [];
            const minId = parseInt(document.getElementById('minId').value);
            const maxId = parseInt(document.getElementById('maxId').value);
            const spacing = 20;
            lines.push({ id: 5, points: line3D(0, 0, 0, 0, 0, 0), rot: 0 });
            let pos = 0;
            for (let i = minId; i <= maxId; i++) {
                pos += spacing;
                lines.push({ id: i, points: line3D(pos, 0, 0, pos, 0, 0), rot: 0 });
            }
            lines.push({ id: 6, points: line3D(pos + spacing, 0, 0, pos + spacing, 0, 0), rot: 0 });
            updateUI();
        }

        document.getElementById('shapeType').addEventListener('change', updateShapeForm);
        document.getElementById('rectPlane').addEventListener('change', updateRectLabels);

        function updateShapeForm() {
            document.querySelectorAll('.shape-form').forEach(f => f.style.display = 'none');
            const sel = document.getElementById('shapeType').value;
            document.getElementById('form-' + sel).style.display = 'block';
            if (sel === 'filledRect') updateRectLabels();
        }

        function updateRectLabels() {
            const plane = document.getElementById('rectPlane').value;
            if (plane === 'xz') {
                document.getElementById('fixedLabel').textContent = 'Fixed Y';
                document.getElementById('min1Label').textContent = 'Min X';
                document.getElementById('max1Label').textContent = 'Max X';
                document.getElementById('min2Label').textContent = 'Min Z';
                document.getElementById('max2Label').textContent = 'Max Z';
            } else if (plane === 'xy') {
                document.getElementById('fixedLabel').textContent = 'Fixed Z';
                document.getElementById('min1Label').textContent = 'Min X';
                document.getElementById('max1Label').textContent = 'Max X';
                document.getElementById('min2Label').textContent = 'Min Y';
                document.getElementById('max2Label').textContent = 'Max Y';
            } else if (plane === 'yz') {
                document.getElementById('fixedLabel').textContent = 'Fixed X';
                document.getElementById('min1Label').textContent = 'Min Y';
                document.getElementById('max1Label').textContent = 'Max Y';
                document.getElementById('min2Label').textContent = 'Min Z';
                document.getElementById('max2Label').textContent = 'Max Z';
            }
        }

        const uploadInput = document.getElementById('imgUpload');
        const previewCanvas = document.getElementById('previewCanvas');
        const pctx = previewCanvas.getContext('2d');

        function processUpload() {
            const file = uploadInput.files && uploadInput.files[0];
            if (!file) { alert('Choose an image file first.'); return; }
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => {
                    const res = Math.max(8, Math.min(512, parseInt(document.getElementById('resValue').value || '128')));
                    const preserve = document.getElementById('preserveAspect').checked;
                    let tw, th;
                    if (preserve) {
                        if (img.width <= img.height) {
                            tw = res;
                            th = Math.round(img.height * (res / img.width));
                        } else {
                            th = res;
                            tw = Math.round(img.width * (res / img.height));
                        }
                    } else {
                        tw = res;
                        th = res;
                    }
                    tw = Math.max(2, Math.min(512, tw));
                    th = Math.max(2, Math.min(512, th));
                    const off = document.createElement('canvas');
                    off.width = tw;
                    off.height = th;
                    const octx = off.getContext('2d');
                    octx.imageSmoothingEnabled = true;
                    octx.drawImage(img, 0, 0, tw, th);
                    const id = octx.getImageData(0, 0, tw, th);
                    const lumArr = new Float32Array(tw * th);
                    for (let i = 0; i < tw * th; i++) {
                        const r = id.data[i * 4], g = id.data[i * 4 + 1], b = id.data[i * 4 + 2], a = id.data[i * 4 + 3];
                        const alpha = a / 255;
                        const rr = r * alpha + 255 * (1 - alpha);
                        const gg = g * alpha + 255 * (1 - alpha);
                        const bb = b * alpha + 255 * (1 - alpha);
                        const lum = 0.2126 * rr + 0.7152 * gg + 0.0722 * bb;
                        lumArr[i] = lum;
                    }
                    const sorted = Float32Array.from(lumArr).sort();
                    const qIndex = (p) => {
                        const idx = Math.floor(p * (sorted.length - 1));
                        return sorted[idx];
                    };
                    const t1 = qIndex(0.25), t2 = qIndex(0.5), t3 = qIndex(0.75);
                    const pixels = [];
                    for (let y = 0; y < th; y++) {
                        const row = [];
                        for (let x = 0; x < tw; x++) {
                            const i = y * tw + x;
                            const lum = lumArr[i];
                            let bin = 0;
                            if (lum <= t1) bin = 0;
                            else if (lum <= t2) bin = 1;
                            else if (lum <= t3) bin = 2;
                            else bin = 3;
                            row.push({ r: id.data[i * 4], g: id.data[i * 4 + 1], b: id.data[i * 4 + 2], a: id.data[i * 4 + 3], lum, bin });
                        }
                        pixels.push(row);
                    }
                    previewPixels = { w: tw, h: th, pixels, t1, t2, t3 };
                    drawPreviewCanvas();
                    const seedSource = (() => {
                        let s = tw + ',' + th + ',' + document.getElementById('pixelSpacing').value + ',' +
                            document.getElementById('offsetX').value + ',' + document.getElementById('offsetY').value + ',' +
                            document.getElementById('offsetZ').value + ',' + (previewPixels.t1.toFixed(3)) + ',' + (previewPixels.t2.toFixed(3)) + ',' + (previewPixels.t3.toFixed(3));
                        const step = Math.max(1, Math.floor((tw * th) / 256));
                        let cnt = 0;
                        for (let y = 0; y < th; y += step) {
                            for (let x = 0; x < tw; x += step) {
                                s += '|' + Math.round(previewPixels.pixels[y][x].lum);
                                if (++cnt > 256) break;
                            }
                            if (cnt > 256) break;
                        }
                        return s;
                    })();
                    lastSeed = fnv1a(seedSource);
                    updatePreviewStats();
                    updateLegend();
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }

        function drawPreviewCanvas() {
            if (!previewPixels) {
                pctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                return;
            }
            const tw = previewPixels.w, th = previewPixels.h;
            const cw = previewCanvas.width, ch = previewCanvas.height;
            const scale = Math.min(cw / tw, ch / th);
            const px = Math.floor(scale * tw), py = Math.floor(scale * th);
            pctx.clearRect(0, 0, cw, ch);
            pctx.save();
            pctx.translate((cw - px) / 2, (ch - py) / 2);
            pctx.imageSmoothingEnabled = false;
            for (let y = 0; y < th; y++) {
                for (let x = 0; x < tw; x++) {
                    const bin = previewPixels.pixels[y][x].bin;
                    let color = '#000000';
                    if (bin === 0) color = '#0000ff';
                    else if (bin === 1) color = '#ff0000';
                    else if (bin === 2) color = '#ffff00';
                    else color = '#ffffff';
                    pctx.fillStyle = color;
                    pctx.fillRect(Math.round(x * scale), Math.round(y * scale), Math.ceil(scale), Math.ceil(scale));
                }
            }
            pctx.restore();
        }

        previewCanvas.addEventListener('click', () => {
            drawPreviewCanvas();
        });

        function updatePreviewStats() {
            if (!previewPixels) return;
            const tw = previewPixels.w, th = previewPixels.h;
            const idSet = new Set();
            const rng = mulberry32(lastSeed);
            for (let y = 0; y < th; y++) {
                for (let x = 0; x < tw; x++) {
                    const bin = previewPixels.pixels[y][x].bin;
                    const id = mapBinToId(bin, rng);
                    idSet.add(id);
                }
            }
            document.getElementById('pixCount').textContent = tw * th;
            document.getElementById('uniqueIDs').textContent = idSet.size;
        }

        function fnv1a(str) {
            let h = 0x811c9dc5 >>> 0;
            for (let i = 0; i < str.length; i++) {
                h ^= str.charCodeAt(i);
                h = Math.imul(h, 0x01000193) >>> 0;
            }
            return h >>> 0;
        }

        function mulberry32(a) {
            return function () {
                let t = (a += 0x6D2B79F5) >>> 0;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }

        function mapBinToId(bin, rng) {
            const ids = [
                parseInt(document.getElementById('idBin0').value || '5'),
                parseInt(document.getElementById('idBin1').value || '6'),
                parseInt(document.getElementById('idBin2').value || '52'),
                parseInt(document.getElementById('idBin3').value || '0')
            ];
            let id = ids[bin];
            if (id !== 0) return id;
            const excluded = new Set(ids.filter(v => v > 0 && v <= 52));
            const valid = [];
            for (let i = 1; i <= 52; i++) if (!excluded.has(i)) valid.push(i);
            if (valid.length === 0) return 1;
            return valid[Math.floor(rng() * valid.length)];
        }

        function updateLegend() {
            document.getElementById('legId0').textContent = document.getElementById('idBin0').value;
            document.getElementById('legId1').textContent = document.getElementById('idBin1').value;
            document.getElementById('legId2').textContent = document.getElementById('idBin2').value;
            const v3 = parseInt(document.getElementById('idBin3').value);
            document.getElementById('legId3').textContent = (v3 === 0 || isNaN(v3)) ? 'random' : v3;
        }

        function convertPreviewToLines() {
            if (!previewPixels) { alert('No preview available — process an image first.'); return; }
            const spacing = parseInt(document.getElementById('pixelSpacing').value) || 1;
            const use4x = document.getElementById('use4x').checked;
            const blockSize = use4x ? 4 : 1;
            const blockHeight = 1;
            const offsetX = parseInt(document.getElementById('offsetX').value) || 0;
            const offsetY = parseInt(document.getElementById('offsetY').value) || 0;
            const offsetZ = parseInt(document.getElementById('offsetZ').value) || 0;
            const seedCompound = (lastSeed ^ fnv1a('' + spacing + ',' + offsetX + ',' + offsetY + ',' + offsetZ + ',' + use4x)) >>> 0;
            const rng = mulberry32(seedCompound);
            const tw = previewPixels.w, th = previewPixels.h;
            for (let py = 0; py < th; py++) {
                for (let px = 0; px < tw; px++) {
                    const bin = previewPixels.pixels[py][px].bin;
                    const id = mapBinToId(bin, rng);
                    const minX = offsetX + px * spacing * blockSize;
                    const minY = offsetY;
                    const minZ = offsetZ + py * spacing * blockSize;
                    const maxX = minX + (blockSize - 1);
                    const maxY = minY + (blockHeight - 1);
                    const maxZ = minZ + (blockSize - 1);
                    for (let y = minY; y <= maxY; y++) {
                        for (let z = minZ; z <= maxZ; z++) {
                            lines.push({
                                id,
                                points: line3D(minX, y, z, maxX, y, z),
                                rot: 0
                            });
                        }
                    }
                }
            }
            updateUI();
            alert(`Pixel art (${use4x ? '4×' : '1×'} blocks, XZ plane) added to the track.`);
        }

        updateShapeForm();
        updateUI();
        (function initPreviewCanvas() {
            const el = document.getElementById('previewCanvas');
            el.width = 320;
            el.height = 320;
        })();
        ['idBin0', 'idBin1', 'idBin2', 'idBin3'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateLegend);
        });
        updateLegend();
    </script>
</body>

</html>
